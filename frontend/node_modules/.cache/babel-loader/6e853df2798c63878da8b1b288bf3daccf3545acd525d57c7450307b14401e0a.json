{"ast":null,"code":"import axios from 'axios';\n// API Configuration\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\nconst API_PREFIX = '/api/v1';\n\n// Create axios instance with default configuration\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000,\n  // 30 seconds timeout\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Request interceptor for logging\napiClient.interceptors.request.use(config => {\n  var _config$method;\n  console.log(`API Request: ${(_config$method = config.method) === null || _config$method === void 0 ? void 0 : _config$method.toUpperCase()} ${config.url}`);\n  return config;\n}, error => {\n  console.error('API Request Error:', error);\n  return Promise.reject(error);\n});\n\n// Response interceptor for error handling\napiClient.interceptors.response.use(response => {\n  console.log(`API Response: ${response.status} ${response.config.url}`);\n  return response;\n}, error => {\n  var _error$response;\n  console.error('API Response Error:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n  return Promise.reject(error);\n});\nexport class ApiService {\n  /**\n   * Send a chat message and get LLM response\n   */\n  static async sendChatMessage(request) {\n    try {\n      const response = await apiClient.post(`${API_PREFIX}/chat`, request);\n      return response.data;\n    } catch (error) {\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get available models\n   */\n  static async getModels() {\n    try {\n      const response = await apiClient.get(`${API_PREFIX}/models`);\n      return response.data;\n    } catch (error) {\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get API status\n   */\n  static async getStatus() {\n    try {\n      const response = await apiClient.get(`${API_PREFIX}/status`);\n      return response.data;\n    } catch (error) {\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Check if API is healthy\n   */\n  static async healthCheck() {\n    try {\n      const response = await apiClient.get('/health');\n      return response.data;\n    } catch (error) {\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Send a streaming chat message and handle Server-Sent Events\n   */\n  static async sendChatMessageStream(request, callbacks) {\n    var _callbacks$onStart, _callbacks$onContent, _callbacks$onEnd, _callbacks$onError;\n    try {\n      var _response$body;\n      const response = await fetch(`${API_BASE_URL}${API_PREFIX}/chat/stream`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(request)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const reader = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.getReader();\n      if (!reader) {\n        throw new Error('Failed to get response reader');\n      }\n      const decoder = new TextDecoder();\n      let buffer = '';\n      try {\n        while (true) {\n          const {\n            done,\n            value\n          } = await reader.read();\n          if (done) break;\n          buffer += decoder.decode(value, {\n            stream: true\n          });\n\n          // Process complete lines\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n          for (const line of lines) {\n            if (line.trim().startsWith('data: ')) {\n              try {\n                const jsonData = line.slice(6).trim();\n                if (jsonData) {\n                  const data = JSON.parse(jsonData);\n                  switch (data.type) {\n                    case 'start':\n                      (_callbacks$onStart = callbacks.onStart) === null || _callbacks$onStart === void 0 ? void 0 : _callbacks$onStart.call(callbacks, data);\n                      break;\n                    case 'content':\n                      (_callbacks$onContent = callbacks.onContent) === null || _callbacks$onContent === void 0 ? void 0 : _callbacks$onContent.call(callbacks, data);\n                      break;\n                    case 'end':\n                      (_callbacks$onEnd = callbacks.onEnd) === null || _callbacks$onEnd === void 0 ? void 0 : _callbacks$onEnd.call(callbacks, data);\n                      break;\n                    case 'error':\n                      (_callbacks$onError = callbacks.onError) === null || _callbacks$onError === void 0 ? void 0 : _callbacks$onError.call(callbacks, data);\n                      break;\n                  }\n                }\n              } catch (parseError) {\n                console.error('Failed to parse SSE data:', parseError, 'Line:', line);\n              }\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    } catch (error) {\n      var _callbacks$onError2;\n      console.error('Streaming error:', error);\n      (_callbacks$onError2 = callbacks.onError) === null || _callbacks$onError2 === void 0 ? void 0 : _callbacks$onError2.call(callbacks, {\n        type: 'error',\n        error: error.message || 'Failed to establish streaming connection'\n      });\n    }\n  }\n\n  /**\n   * Handle API errors consistently\n   */\n  static handleApiError(error) {\n    if (error.response) {\n      // Server responded with error status\n      const apiError = error.response.data;\n      return new Error(apiError.error || `API Error: ${error.response.status}`);\n    } else if (error.request) {\n      // Request was made but no response received\n      return new Error('Network error: Unable to connect to the server');\n    } else {\n      // Something else happened\n      return new Error(`Request error: ${error.message}`);\n    }\n  }\n}","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_URL","API_PREFIX","apiClient","create","baseURL","timeout","headers","interceptors","request","use","config","_config$method","console","log","method","toUpperCase","url","error","Promise","reject","response","status","_error$response","data","message","ApiService","sendChatMessage","post","handleApiError","getModels","get","getStatus","healthCheck","sendChatMessageStream","callbacks","_callbacks$onStart","_callbacks$onContent","_callbacks$onEnd","_callbacks$onError","_response$body","fetch","body","JSON","stringify","ok","Error","reader","getReader","decoder","TextDecoder","buffer","done","value","read","decode","stream","lines","split","pop","line","trim","startsWith","jsonData","slice","parse","type","onStart","call","onContent","onEnd","onError","parseError","releaseLock","_callbacks$onError2","apiError"],"sources":["/Users/hungyie/Downloads/Axium-Technical-Interview/frontend/src/services/api.ts"],"sourcesContent":["import axios, { AxiosResponse } from 'axios';\nimport {\n  ChatRequest,\n  ChatResponse,\n  ApiStatus,\n  ModelsResponse,\n  ApiError,\n  StreamChunk,\n  StreamCallback\n} from '../types/api';\n\n// API Configuration\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\nconst API_PREFIX = '/api/v1';\n\n// Create axios instance with default configuration\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000, // 30 seconds timeout\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Request interceptor for logging\napiClient.interceptors.request.use(\n  (config) => {\n    console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`);\n    return config;\n  },\n  (error) => {\n    console.error('API Request Error:', error);\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor for error handling\napiClient.interceptors.response.use(\n  (response) => {\n    console.log(`API Response: ${response.status} ${response.config.url}`);\n    return response;\n  },\n  (error) => {\n    console.error('API Response Error:', error.response?.data || error.message);\n    return Promise.reject(error);\n  }\n);\n\nexport class ApiService {\n  /**\n   * Send a chat message and get LLM response\n   */\n  static async sendChatMessage(request: ChatRequest): Promise<ChatResponse> {\n    try {\n      const response: AxiosResponse<ChatResponse> = await apiClient.post(\n        `${API_PREFIX}/chat`,\n        request\n      );\n      return response.data;\n    } catch (error: any) {\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get available models\n   */\n  static async getModels(): Promise<ModelsResponse> {\n    try {\n      const response: AxiosResponse<ModelsResponse> = await apiClient.get(\n        `${API_PREFIX}/models`\n      );\n      return response.data;\n    } catch (error: any) {\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get API status\n   */\n  static async getStatus(): Promise<ApiStatus> {\n    try {\n      const response: AxiosResponse<ApiStatus> = await apiClient.get(\n        `${API_PREFIX}/status`\n      );\n      return response.data;\n    } catch (error: any) {\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Check if API is healthy\n   */\n  static async healthCheck(): Promise<{ status: string; service: string }> {\n    try {\n      const response = await apiClient.get('/health');\n      return response.data;\n    } catch (error: any) {\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Send a streaming chat message and handle Server-Sent Events\n   */\n  static async sendChatMessageStream(\n    request: ChatRequest, \n    callbacks: StreamCallback\n  ): Promise<void> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_PREFIX}/chat/stream`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(request),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('Failed to get response reader');\n      }\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          \n          if (done) break;\n          \n          buffer += decoder.decode(value, { stream: true });\n          \n          // Process complete lines\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || ''; // Keep incomplete line in buffer\n          \n          for (const line of lines) {\n            if (line.trim().startsWith('data: ')) {\n              try {\n                const jsonData = line.slice(6).trim();\n                if (jsonData) {\n                  const data: StreamChunk = JSON.parse(jsonData);\n                  \n                  switch (data.type) {\n                    case 'start':\n                      callbacks.onStart?.(data);\n                      break;\n                    case 'content':\n                      callbacks.onContent?.(data);\n                      break;\n                    case 'end':\n                      callbacks.onEnd?.(data);\n                      break;\n                    case 'error':\n                      callbacks.onError?.(data);\n                      break;\n                  }\n                }\n              } catch (parseError) {\n                console.error('Failed to parse SSE data:', parseError, 'Line:', line);\n              }\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    } catch (error: any) {\n      console.error('Streaming error:', error);\n      callbacks.onError?.({\n        type: 'error',\n        error: error.message || 'Failed to establish streaming connection'\n      });\n    }\n  }\n\n  /**\n   * Handle API errors consistently\n   */\n  private static handleApiError(error: any): Error {\n    if (error.response) {\n      // Server responded with error status\n      const apiError: ApiError = error.response.data;\n      return new Error(apiError.error || `API Error: ${error.response.status}`);\n    } else if (error.request) {\n      // Request was made but no response received\n      return new Error('Network error: Unable to connect to the server');\n    } else {\n      // Something else happened\n      return new Error(`Request error: ${error.message}`);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}